{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/index.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","canvas","$","dots","dotsArray","el","context","getContext","h1","canvasWidth","innerWidth","canvasHeight","innerHeight","config","dotSize","numOfDots","directions","speeds","stage","init","layout","type","moveDot","TypeIt","loop","exec","Promise","resolve","setTimeout","delete","go","shrinkBox","stage3","addClass","removeClass","clearRect","random","Math","floor","xMove","yMove","x","speed","y","drawDot","position","left","top","height","width","color","radius","requestAnimationFrame","attr","dot","sin","drawLine","duplet","strokeStyle","beginPath","moveTo","lineTo","stroke","globalAlpha","arc","PI","fillStyle","fill"],"mappings":"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","file":"js/app.b97445a4.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([46,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","const isPrime = num => {\n  for (var i = 2; i < num; i++) if (num % i == 0) return false;\n  return num >= 2; \n};\n\nvar canvas = $('canvas.dots');\nvar dots = {\n  dotsArray: [],\n  el: {\n    context: canvas[0].getContext('2d'),\n    h1: $('h1'),\n    canvasWidth: window.innerWidth,\n    canvasHeight: window.innerHeight, // this one is new\n  },\n  config : {\n    \n    dotSize: 5,\n    numOfDots:  400,\n    directions: ['+', '-'],\n    speeds: [0.5, 1, 1.5, 2, 2.5],\n    stage: 0\n  },\n  \n  init: function(){\n   \n    \n    dots.layout();\n    dots.type();\n    dots.moveDot();\n    // setTimeout(function(){\n    //   dots.config.stage = 1;\n    //   // $('.page-1').addClass('hidden');\n    //   // $('.page-2').removeClass('hidden');\n    // }, 5000);\n  },\n  type: function() {\n    dots.config.stage = 0;\n    new TypeIt(\"h1\", {\n      // speed: 75,\n      loop: true,\n      // afterString: async (step, instance) => {\n      //   step.freeze()\n      // } \n\n    }).type('We live in uncertain times.').exec(\n      function(){\n       return new Promise(resolve => {\n         dots.config.stage = 0;\n \n         setTimeout(() => {\n           resolve();\n         }, 3000);\n       });\n       }  \n     ).delete().type('Disruptive technologies.').exec(\n     function(){\n      return new Promise(resolve => {\n        dots.config.stage = 1;\n\n        setTimeout(() => {\n          resolve();\n        }, 3000);\n      });\n      }  \n    ).delete().type('Shifting trends.').exec(\n      function(){\n       return new Promise(resolve => {\n         dots.config.stage = 2;\n \n         setTimeout(() => {\n           resolve();\n         }, 1000);\n       });\n       }  \n     )\n     .delete().type('Political Risks.').exec(\n      function(){\n       return new Promise(resolve => {\n         dots.config.stage = 3;\n \n         setTimeout(() => {\n           resolve();\n         }, 5000);\n       });\n       }  \n     )\n     .go();\n  },\n  shrinkBox: function(){\n    var i = 0;\n      // canvas.attr({height: dots.el.canvasHeight - i, width: dots.el.canvasWidth - i});\n    \n  },\n  stage3: function() {\n    $('.page-1').addClass('hidden');\n    $('.page-2').removeClass('hidden');\n    // dots.el.context.font = \"30px Arial\";\n    // dots.el.context.fillText(\"Hello World\", 10, 50);\n  },\n  moveDot: function(){\n    const {canvasWidth, canvasHeight} = dots.el;\n    // if(dots.config.stage == 1){\n    //   dots.el.canvasWidth--;\n    //   dots.el.canvasHeight--;\n    //   canvas.attr({height: dots.el.canvasHeight, width: dots.el.canvasWidth});\n    // }\n    \n    dots.el.context.clearRect(0, 0, canvasWidth, canvasHeight);\n    // var dots = dots.dotsArray;\n    var i = 0;\n    var d = dots.dotsArray;\n    for( i = 0; i < d.length; i++ ) {\n\n      var random = Math.floor(Math.random() * Math.floor(500));\n\n      if (dots.config.stage == 0){\n\n        if(random == 1){\n          d[i].xMove = '-';\n        }\n        if(random == 2){\n          d[i].xMove = '+';\n        }\n        if(random == 3){\n          d[i].yMove = '-';\n        }\n        if(random == 4){\n          d[i].yMove = '+';\n        }\n      }\n\n\n      if( d[i].xMove == '+' ) {\n        d[i].x += d[i].speed;\n      } else {\n        d[i].x -= d[i].speed;\n      }\n      if( d[i].yMove == '+' ) {\n        d[i].y += d[i].speed;\n      } else {\n        d[i].y -= d[i].speed;\n      }\n      \n      \n  \n      dots.drawDot(d[i]);\n\n      \n  \n      \n      if (dots.config.stage == 1){\n\n        if( d[i].x > dots.el.h1.position().left && d[i].y > (dots.el.h1.position().top) &&  d[i].y < dots.el.h1.position().top + dots.el.h1.height() && d[i].x < dots.el.h1.position().left + dots.el.h1.width()){\n\n          dots.dotsArray[i].color = '#F55151';\n        \n        }\n      }\n\n      if (dots.config.stage == 2){\n        d[i].color = 'rgb(255,255,255)';\n        // if( (d[i].y + d[i].radius) < canvasHeight /2) {\n          d[i].yMove = '+';\n        // }\n\n      }\n      // var center = [canvasWidth / 2, canvasHeight / 2];\n      //   if(Math.floor(d[i].x) == Math.floor(center[0])){\n      //     if(d[i].xMove == '+'){\n\n      //       d[i].xMove = '-';\n      //     }  else {\n      //       d[i].xMove = '+';\n      //     }       \n\n      //   }\n        \n\n\n\n      // // if (dots.config.stage == 3){\n      //   var center = [canvasWidth / 2, canvasHeight / 2];\n\n      //   if(d[i].x  center[0])\n      //   {\n      //     d[i].color == 'red';\n      //     d[i].xMove = '-';\n      //   } else if(d[i].x == center[0] && d[i].xMove == '-' )\n      //   {\n      //     d[i].xMove = '+';\n      //   }\n        // d[i].speed =Math.sin(i) / 4;\n\n        // if(isPrime(i) && i < 30){\n        //   // dots.drawLine([d[i], d[i + 1]]);\n        // }\n    // }\n\n      \n\n      if( (d[i].x + d[i].radius) >= canvasWidth ) {\n        d[i].xMove = '-';\n      }\n      if( (d[i].x - d[i].radius) <= 0 ) {\n        d[i].xMove = '+';\n      }\n      if( (d[i].y + d[i].radius) >= canvasHeight ) {\n        d[i].yMove = '-';\n      }\n      if( (d[i].y - d[i].radius) <= 0 ) {\n        d[i].yMove = '+';\n      }\n        // var center = [canvasWidth / 2, canvasHeight / 2];\n        // var xDist = center[0] - d[i].x;\n        // var yDist = center[1] - d[i].y;\n        // var distance = Math.sqrt((xDist * xDist) + (yDist * yDist));\n        // // console.log(distance);\n        // if(distance > 400){\n        //   // d[i].color = 'red';\n        //   if(xDist > 0){\n        //     d[i].color = 'red';\n        //       d[i].xMove = '-';\n        //   // } else {\n        //   //   d[i].color = 'blue';\n        //   //   d[i].xMove = '+';\n        //   }\n        // //   d[i].xMove = '-';\n        // } else {\n        //   d[i].color = 'white';\n\n        // }\n\n      // }\n    }\n  \n    window.requestAnimationFrame(dots.moveDot);\n  },\n  layout: function(){\n    canvas.attr({height: dots.el.canvasHeight, width: dots.el.canvasWidth});\n    \n    dots.dotsArray = [];\n    for(var i = 0; i < dots.config.numOfDots; i++) {\n      var x = Math.random() * dots.el.canvasWidth;\n      var y = Math.random() * dots.el.canvasHeight;\n      // Get random color, direction and speed.\n      var xMove = dots.config.directions[Math.floor(Math.random() * dots.config.directions.length)];\n      var yMove = dots.config.directions[Math.floor(Math.random() * dots.config.directions.length)];\n      var speed = dots.config.speeds[Math.floor(Math.random() * dots.config.speeds.length)];\n      var dot = {\n        x: x,\n        y: y,\n        radius: Math.floor(Math.random() * 5),\n        xMove: xMove,\n        yMove: yMove,\n        color: 'rgb(255,255,255)',\n        speed: Math.sin(i) * 2,\n      };\n      // Save it to the dots array.\n      dots.dotsArray.push(dot);\n      // console.log(dotsArray);\n      dots.drawDot(dot);\n    }\n  },\n  drawLine: function(duplet){\n        dots.el.context.strokeStyle = '(255,255,2.2)';\n        dots.el.context.beginPath();\n        dots.el.context.moveTo(duplet[0].x, duplet[0].y);\n        dots.el.context.lineTo(duplet[1].x, duplet[1].y);\n        dots.el.context.stroke();\n  },\n  drawDot: function(dot) {\n    //     // Set transparency on the dots.\n        dots.el.context.globalAlpha = 0.7;\n        dots.el.context.beginPath();\n        dots.el.context.arc(dot.x, dot.y, dot.radius, 0, 2 * Math.PI, false);\n        dots.el.context.fillStyle = dot.color;\n        dots.el.context.fill();\n      }\n};\n\ndots.init();\n  \n  // Start with an empty array of dots.\n  \n  \n  \n  \n  // Draw each dot in the dots array.\n  \n//   setTimeout(function(){\n//     window.requestAnimationFrame(moveDot);\n//   }, 2500);\n  \n  \n//   function moveDot() {\n//     context.clearRect(0, 0, canvasWidth, canvasHeight);\n  \n//     for( i = 0; i < dots.length; i++ ) {\n  \n//       if( dots[i].xMove == '+' ) {\n//         dots[i].x += dots[i].speed;\n//       } else {\n//         dots[i].x -= dots[i].speed;\n//       }\n//       if( dots[i].yMove == '+' ) {\n//         dots[i].y += dots[i].speed;\n//       } else {\n//         dots[i].y -= dots[i].speed;\n//       }\n  \n//       drawDot(dots[i]);\n  \n//       if( (dots[i].x + dots[i].radius) >= canvasWidth ) {\n//         dots[i].xMove = '-';\n//       }\n//       if( (dots[i].x - dots[i].radius) <= 0 ) {\n//         dots[i].xMove = '+';\n//       }\n//       if( (dots[i].y + dots[i].radius) >= canvasHeight ) {\n//         dots[i].yMove = '-';\n//       }\n//       if( (dots[i].y - dots[i].radius) <= 0 ) {\n//         dots[i].yMove = '+';\n//       }\n  \n//       if(bump){\n//         dots[i].yMove = '+';\n//       }\n//     }\n  \n//     window.requestAnimationFrame(moveDot);\n//   }\n  \n//   function drawDot(dot) {\n//     // Set transparency on the dots.\n//     context.globalAlpha = 0.9;\n//     context.beginPath();\n//     context.arc(dot.x, dot.y, dot.radius, 0, 2 * Math.PI, false);\n//     context.fillStyle = dot.color;\n//     context.fill();\n//   }\n// }\n\n\n// import * as d3 from \"d3\";\n// import _ from \"lodash\";\n// /**\n//  * Given a set of points, lay them out in a phyllotaxis layout.\n//  * Mutates the `points` passed in by updating the x and y values.\n//  *\n//  * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n//  * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n//  * @param {Number} xOffset The x offset to apply to all points\n//  * @param {Number} yOffset The y offset to apply to all points\n//  *\n//  * @return {Object[]} points with modified x and y\n//  */\n// function phyllotaxisLayout(points, pointWidth, xOffset = 0, yOffset = 0, iOffset = 0) {\n//   // theta determines the spiral of the layout\n//   const theta = Math.PI * (3 - Math.sqrt(5));\n\n//   const pointRadius = pointWidth / 2;\n\n//   points.forEach((point, i) => {\n//     const index = (i + iOffset) % points.length;\n//     const phylloX = pointRadius * Math.sqrt(index) * Math.cos(index * theta);\n//     const phylloY = pointRadius * Math.sqrt(index) * Math.sin(index * theta);\n\n//     point.x = xOffset + phylloX - pointRadius;\n//     point.y = yOffset + phylloY - pointRadius;\n//   });\n\n//   return points;\n// }\n\n// /**\n//  * Given a set of points, lay them out in a grid.\n//  * Mutates the `points` passed in by updating the x and y values.\n//  *\n//  * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n//  * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n//  * @param {Number} gridWidth The width of the grid of points\n//  *\n//  * @return {Object[]} points with modified x and y\n//  */\n// function gridLayout(points, pointWidth, gridWidth) {\n//   const pointHeight = pointWidth;\n//   const pointsPerRow = Math.floor(gridWidth / pointWidth);\n//   const numRows = points.length / pointsPerRow;\n\n//   points.forEach((point, i) => {\n//     point.x = pointWidth * (i % pointsPerRow);\n//     point.y = pointHeight * Math.floor(i / pointsPerRow);\n//   });\n\n//   return points;\n// }\n\n// /**\n//  * Given a set of points, lay them out randomly.\n//  * Mutates the `points` passed in by updating the x and y values.\n//  *\n//  * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n//  * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n//  * @param {Number} width The width of the area to place them in\n//  * @param {Number} height The height of the area to place them in\n//  *\n//  * @return {Object[]} points with modified x and y\n//  */\n// function randomLayout(points, pointWidth, width, height) {\n//   points.forEach((point, i) => {\n//     point.x = Math.random() * (width - pointWidth);\n//     point.y = Math.random() * (height - pointWidth);\n//   });\n\n//   return points;\n// }\n\n// function bottomLayout(points, pointWidth, width, height) {\n//   var min = Math.ceil(0.5);\n//   var max = Math.floor(1);\n//   points.forEach((point, i) => {\n//     point.x = Math.random() * (width - pointWidth);\n//     point.y = ((Math.random() / 2) + 0.5) * (height - pointWidth);\n//   });\n\n//   return points;\n// }\n\n// /**\n//  * Given a set of points, lay them out in a sine wave.\n//  * Mutates the `points` passed in by updating the x and y values.\n//  *\n//  * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n//  * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n//  * @param {Number} width The width of the area to place them in\n//  * @param {Number} height The height of the area to place them in\n//  *\n//  * @return {Object[]} points with modified x and y\n//  */\n// function sineLayout(points, pointWidth, width, height) {\n//   const amplitude = 0.3 * (height / 2);\n//   const yOffset = height / 2;\n//   const periods = 3;\n//   const yScale = d3.scaleLinear()\n//     .domain([0, points.length - 1])\n//     .range([0, periods * 2 * Math.PI]);\n\n//   points.forEach((point, i) => {\n//     point.x = (i / points.length) * (width - pointWidth);\n//     point.y = amplitude * Math.sin(yScale(i)) + yOffset;\n//   });\n\n//   return points;\n// }\n\n// /**\n//  * Given a set of points, lay them out in a spiral.\n//  * Mutates the `points` passed in by updating the x and y values.\n//  *\n//  * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n//  * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n//  * @param {Number} width The width of the area to place them in\n//  * @param {Number} height The height of the area to place them in\n//  *\n//  * @return {Object[]} points with modified x and y\n//  */\n// function spiralLayout(points, pointWidth, width, height) {\n//   const amplitude = 0.3 * (height / 2);\n//   const xOffset = width / 2;\n//   const yOffset = height / 2;\n//   const periods = 20;\n\n//   const rScale = d3.scaleLinear()\n//     .domain([0, points.length -1])\n//     .range([0, Math.min(width / 2, height / 2) - pointWidth]);\n\n//   const thetaScale = d3.scaleLinear()\n//     .domain([0, points.length - 1])\n//     .range([0, periods * 2 * Math.PI]);\n\n//   points.forEach((point, i) => {\n//     point.x = rScale(i) * Math.cos(thetaScale(i)) + xOffset;\n//     point.y = rScale(i) * Math.sin(thetaScale(i)) + yOffset;\n//   });\n\n//   return points;\n// }\n\n\n\n\n// /**\n//  * Generate an object array of `numPoints` length with unique IDs\n//  * and assigned colors\n//  */\n// function createPoints(numPoints, pointWidth, width, height) {\n//   const colorScale = d3.scaleSequential(d3.interpolateViridis)\n//     .domain([numPoints - 1, 0]);\n\n//   const points = d3.range(numPoints).map(id => ({\n//     id,\n//     color: colorScale(id),\n//   }));\n\n//   return randomLayout(points, pointWidth, width, height);\n// }\n\n// // canvas settings\n// const width = 600;\n// const height = 600;\n\n// // point settings\n// const numPoints = 7000;\n// const pointWidth = 2;\n// const pointMargin = 3;\n\n// // animation settings\n// const duration = 1500;\n// const ease = d3.easeCubic;\n// let timer;\n// let currLayout = 0;\n\n// // create set of points\n// const points = createPoints(numPoints, pointWidth, width, height);\n\n// // wrap layout helpers so they only take points as an argument\n// const toGrid = (points) => gridLayout(points,\n//   pointWidth + pointMargin, width);\n// const toSine = (points) => sineLayout(points,\n//   pointWidth + pointMargin, width, height);\n// const toSpiral = (points) => spiralLayout(points,\n//   pointWidth + pointMargin, width, height);\n// const toPhyllotaxis = (points) => phyllotaxisLayout(points,\n//   pointWidth + pointMargin, width / 2, height / 2);\n// const toRandom = (points) => randomLayout(points,\n//     pointWidth + pointMargin, width, height);\n\n// const toBottom = (points) => bottomLayout(points,\n//       pointWidth + pointMargin, width, height);\n\n      \n// // store the layouts in an array to sequence through\n// const layouts = [toRandom, toBottom];\n\n// // draw the points based on their current layout\n// function draw() {\n//   const ctx = canvas.node().getContext('2d');\n//   ctx.save();\n\n//   // erase what is on the canvas currently\n//   ctx.clearRect(0, 0, width, height);\n\n//   // draw each point as a rectangle\n//   for (let i = 0; i < points.length; ++i) {\n//     const point = points[i];\n//     ctx.fillStyle = point.color;\n//     ctx.beginPath();\n//     ctx.arc(point.x, point.y, pointWidth, 0, 2 * Math.PI, true);\n//     ctx.closePath();\n//     ctx.fill();\n\n//   }\n\n//   ctx.restore();\n// }\n\n// // animate the points to a given layout\n// function animate(layout) {\n//   // store the source position\n//   points.forEach(point => {\n//     point.sx = point.x;\n//     point.sy = point.y;\n//   });\n\n//   // get destination x and y position on each point\n//   layout(points);\n\n//   // store the destination position\n//   points.forEach(point => {\n//     point.tx = point.x;\n//     point.ty = point.y;\n//   });\n\n  \n\n//   d3.timer((elapsed) => {\n//     // console.log(elapsed);\n//     // console.log(points);\n//   });\n\n//   timer = d3.timer((elapsed) => {\n//     // compute how far through the animation we are (0 to 1)\n//     const t = Math.min(1, ease(elapsed / duration));\n\n//     // update point positions (interpolate between source and target)\n//     points.forEach((point, key) => {\n//       if (key){\n//         point.x = point.sx * (1 - t) + point.tx * t;\n//         point.y = point.sy * (1 - t) + point.ty * t;\n//       }\n//     });\n\n//     // update what is drawn on screen\n//     draw();\n\n//     // if this animation is over\n//     if (t === 1) {\n//       // stop this timer for this layout and start a new one\n//       timer.stop();\n\n//       // update to use next layout\n//       currLayout = (currLayout + 1) % layouts.length;\n\n//       // start animation for next layout\n//       animate(layouts[currLayout]);\n//     }\n//   });\n// }\n\n// // create the canvas\n// const screenScale = window.devicePixelRatio || 1;\n// const canvas = d3.select('body').append('canvas')\n//   .attr('width', width * screenScale)\n//   .attr('height', height * screenScale)\n//   .style('width', `${width}px`)\n//   .style('height', `${height}px`);\n// canvas.node().getContext('2d').scale(screenScale, screenScale);\n\n// // start off as a grid\n// toRandom(points);\n// draw();\n\n\n// d3.select('body').append('div');\n\n//   // start the animation\n// animate(layouts[currLayout]);\n\n\n// // var data = require(\"../data.json\"); //(with path)\n\n// // const COS = Math.cos;\n// // const SIN = Math.sin;\n// // const PI = Math.PI;\n\n// // var config = {\n// //   logo: {\n// //     width: 510,\n// //     height: 64,\n// //     ratio: 1.1,\n// //     position: \"Center\",\n// //     presets: [\"Center\", \"Bottom\", \"Right\"],\n// //   },\n// //   users: {\n// //     selected: \"All\",\n// //     presets: [],\n// //   },\n// //   nodeSize: 1.5,\n// //   edgeSize: 0.9,\n// //   innerRadius: 106,\n// //   outterRadius: 248,\n// //   rotation: 0,\n// //   animated: true,\n// //   animation: {\n// //     innerRadius: 106,\n// //     outterRadius: 248,\n// //   },\n// //   color: {\n// //     start: \"#052349\",\n// //     end: \"#fd575f\",\n// //     nodes: \"#FFFFFF\",\n// //   },\n// //   iterate: COS(PI / 2),\n// //   speed: 1,\n// // };\n\n// // var getAll = function (data, attr) {\n// //   var item, _i, _len, _results;\n// //   _results = [];\n// //   for (_i = 0, _len = data.length; _i < _len; _i++) {\n// //     item = data[_i];\n// //     _results.push(item[attr]);\n// //   }\n// //   return _results;\n// // };\n\n// // var context = {\n// //   start: _.min(data, function (d) {\n// //     return d.start;\n// //   }).start,\n// //   end: _.max(data, function (d) {\n// //     return d.start;\n// //   }).start,\n// //   users: getAll(\n// //     _.uniq(data, function (d) {\n// //       return d.user;\n// //     }),\n// //     \"user\"\n// //   ).sort(),\n// // };\n\n\n// // const line = d3\n// //   .line()\n// //   .x(function (d) {\n// //     return d.x;\n// //   })\n// //   .y(function (d) {\n// //     return d.y;\n// //   });\n\n// // const dots = {\n// //   el: {\n// //     svg: d3.select(\"#dots\").selectAll(\"svg\").data([{}]).enter().append(\"svg\"),\n// //     button: document.getElementById(\"demo\")\n// //   },\n\n// //   params: {\n// //     width: window.innerWidth,\n// //     height: window.innerHeight,\n// //     position: \"Center\",\n// //     center: {\n// //       x: window.innerWidth / 2,\n// //       y: window.innerHeight / 2,\n// //     },\n// //   },\n// //   controls: {\n// //     overlapsTask: true,\n// //     followingTask: true,\n// //     followingLimit: 48,\n// //   },\n// //   timeScale: d3\n// //     .scaleLinear()\n// //     .domain([context.start, context.end])\n// //     .range([0, PI * 2]),\n// //   userScale: d3\n// //     .scaleLinear()\n// //     .domain([0, context.users.length - 1])\n// //     .range([config.innerRadius, config.outterRadius]),\n// //   init: function () {\n// //     dots.loadSVG();\n// //     dots.defineTimeScale();\n// //     dots.resize();\n// //     dots.circularSVG();\n// //     dots.bindUIActions();\n// //     dots.animate();\n// //     dots.updateGradient();\n// //   },\n// //   bindUIActions: function(){\n// //     dots.el.button.addEventListener(\"click\", function(){\n// //         config.rotation = 10;\n// //         dots.circularSVG();\n// //       });\n// //   },\n\n// //   loadSVG: function () {\n// //     let svg = dots.el.svg;\n// //     svg.defs = svg.selectAll(\"defs\").data([{}]);\n// //     svg.defs = svg.defs.enter().append(\"defs\");\n// //     svg.defs\n// //       .append(\"radialGradient\")\n// //       .attr(\"gradientUnits\", \"userSpaceOnUse\")\n// //       .attr(\"cx\", \"0%\")\n// //       .attr(\"cy\", \"0%\")\n// //       .attr(\"fx\", \"0%\")\n// //       .attr(\"fy\", \"0%\")\n// //       .attr(\"r\", \"\" + config.outterRadius + \"px\")\n// //       .attr(\"spreadMethod\", \"pad\")\n// //       .attr(\"id\", \"radial-gradient\");\n\n// //     svg.defs\n// //       .select(\"#radial-gradient\")\n// //       .append(\"stop\")\n// //       .attr(\"stop-color\", \"#f4c31e\")\n// //       .attr(\"stop-opacity\", \"1\")\n// //       .attr(\"offset\", \"30%\");\n\n// //     svg.defs\n// //       .select(\"#radial-gradient\")\n// //       .append(\"stop\")\n// //       .attr(\"stop-color\", \"#00bdcc\")\n// //       .attr(\"stop-opacity\", \"1\")\n// //       .attr(\"offset\", \"100%\");\n\n// //     svg.background = svg.selectAll(\"rect.background\").data([{}]);\n// //     svg.background\n// //       .enter()\n// //       .append(\"rect\")\n// //       .classed(\"background\", true)\n// //       .style(\"fill\", \"#191e28\")\n// //       .attr(\"width\", dots.params.width)\n// //       .attr(\"height\", dots.params.height);\n\n// //     svg.graph = svg.selectAll(\"g.graph\").data([{}]);\n// //     svg.graph = svg.graph.enter().append(\"g\").classed(\"graph\", true);\n// //     svg.edges = svg.graph.selectAll(\"g.edges\").data([{}]);\n// //     svg.edges = svg.edges.enter().append(\"g\").classed(\"edges\", true);\n// //     svg.nodes = svg.graph.selectAll(\"g.nodes\").data([{}]);\n// //     svg.nodes = svg.nodes.enter().append(\"g\").classed(\"nodes\", true);\n// //   },\n\n// //   defineTimeScale: function () {\n// //     var angles, day, dayScope, i, key, projectsGroups, step, _i, _ref;\n// //     projectsGroups = _.groupBy(data, function (d) {\n// //       return (\n// //         Math.round(new Date(d.start).getMinutes() / 10) +\n// //         \"-\" +\n// //         new Date(d.start).getHours() +\n// //         \"-\" +\n// //         new Date(d.start).getDate() +\n// //         \"-\" +\n// //         new Date(d.start).getMonth()\n// //       );\n// //     });\n// //     dayScope = [];\n// //     angles = [];\n// //     for (key in projectsGroups) {\n// //       day = projectsGroups[key];\n// //       dayScope = dayScope.concat(\n// //         d3.extent(day, function (d) {\n// //           return new Date(d.start);\n// //         })\n// //       );\n// //     }\n// //     step = 360 / (dayScope.length - 1);\n// //     for (\n// //       i = _i = 0, _ref = 360 / step;\n// //       0 <= _ref ? _i <= _ref : _i >= _ref;\n// //       i = 0 <= _ref ? ++_i : --_i\n// //     ) {\n// //       angles = angles.concat([i * step * 0.0174532925]);\n// //     }\n\n// //     dots.timeScale = d3.scaleLinear().domain(dayScope).range(angles);\n// //   },\n\n// //   circularPosition: function (d, center) {\n// //     d.x =\n// //       COS(dots.timeScale(new Date(d.start))) *\n// //       dots.userScale(context.users.indexOf(d.user));\n// //     d.y =\n// //       SIN(dots.timeScale(new Date(d.start))) *\n// //       dots.userScale(context.users.indexOf(d.user));\n// //     return d;\n// //   },\n// //   circularSVG: function () {\n// //     let svg = dots.el.svg;\n\n// //     var circles, edges;\n// //     var center = dots.params.center;\n// //     if (config.animated) {\n// //         dots.userScale.range([config.animation.innerRadius, config.animation.outterRadius]);\n// //       } else {\n// //         dots.userScale.range([config.innerRadius, config.outterRadius]);\n// //       }\n// //     svg.graph.attr(\n// //       \"transform\",\n// //       \"translate(\" +\n// //         center.x +\n// //         \" \" +\n// //         center.y +\n// //         \")rotate(\" +\n// //         config.rotation +\n// //         \")\"\n// //     );\n// //     circles = svg.nodes.selectAll(\"circle\").data(data);\n// //     circles = circles\n// //       .enter()\n// //       .append(\"circle\")\n// //       .style(\"fill\", config.color.nodes);\n// //     circles.each(function (d, i) {\n// //       var elem, selected;\n// //       elem = d3.select(this);\n// //       selected = false;\n// //       dots.circularPosition(d, center);\n// //       return elem.attr(\"cx\", d.x).attr(\"cy\", d.y).attr(\"r\", config.nodeSize);\n// //     });\n// //     circles.exit().remove();\n\n// //     if (dots.links == null) {\n// //       dots.createLinks();\n// //     }\n// //     edges = svg.edges.selectAll(\"path\").data(dots.links);\n// //     edges = edges.enter().append(\"path\");\n// //     edges\n// //       .style(\"fill\", \"none\")\n// //       .style(\"stroke\", \"green\")\n// //       .style(\"stroke\", \"url(#radial-gradient)\");\n// //     edges.attr(\"d\", line)\n// //       .style(\"stroke-width\", config.edgeSize)\n// //       .style(\"stroke-linecap\", \"round\")\n// //       .style(\"stroke-linejoin\", \"round\");\n// //     edges.exit().remove();\n// //   },\n// //   resize: function () {\n// //     let svg = dots.el.svg;\n// //     dots.params.width = window.innerWidth;\n// //     dots.params.height = window.innerHeight;\n// //     // defineCenter(dots.params.position);\n// //     svg.attr(\"width\", window.innerWidth).attr(\"height\", window.innerHeight);\n// //     svg.background\n// //       .attr(\"width\", dots.params.width)\n// //       .attr(\"height\", dots.params.height);\n// //     if (dots.circularSVG != null) {\n// //       dots.circularSVG();\n// //     }\n// //   },\n// //   createLinks: function () {\n// //     dots.links = dots.getLinks(data, dots.controls);\n// //     dots.links = dots.buildLinks(data, dots.links);\n// //   },\n// //   getLinks: function (data, controls) {\n// //     var item, link, links, _i, _j, _len, _len1;\n// //     links = linksTool(data, controls);\n// //     for (_i = 0, _len = links.length; _i < _len; _i++) {\n// //       link = links[_i];\n// //       for (_j = 0, _len1 = data.length; _j < _len1; _j++) {\n// //         item = data[_j];\n// //         if (item.id === link.source) {\n// //           link.source = item;\n// //         }\n// //         if (item.id === link.target) {\n// //           link.target = item;\n// //         }\n// //       }\n// //     }\n// //     return links;\n// //   },\n// //   buildLinks: function (data, links) {\n// //     var count,\n// //       group,\n// //       index,\n// //       last,\n// //       link,\n// //       paths,\n// //       result,\n// //       singles,\n// //       _i,\n// //       _len,\n// //       _links,\n// //       _ref;\n// //     result = [];\n// //     singles = [];\n// //     _ref = _.groupBy(links, function (d) {\n// //       return d.index;\n// //     });\n// //     for (index in _ref) {\n// //       group = _ref[index];\n// //       if (eval(index) != null) {\n// //         _links = [];\n// //         last = null;\n// //         for (_i = 0, _len = group.length; _i < _len; _i++) {\n// //           link = group[_i];\n// //           _links.push(link.source);\n// //         }\n// //         _links.push(group[group.length - 1].target);\n// //         result = result.concat([_links]);\n// //       } else {\n// //         singles = singles.concat(group);\n// //       }\n// //     }\n// //     paths = [];\n// //     singles.sort(function (a, b) {\n// //       return a.start - b.start;\n// //     });\n// //     count = 0;\n// //     while (count < singles.length - 1) {\n// //       paths.push(dots.definePath(singles[count], singles));\n// //       ++count;\n// //     }\n// //     result = result.concat(paths);\n// //     return result;\n// //   },\n// //   definePath: function (single, data) {\n// //     var count, last, list, recurse, _data;\n// //     _data = data;\n// //     count = 0;\n// //     last = null;\n// //     list = [];\n// //     list.push(single.source);\n// //     recurse = function (obj, datum) {\n// //       var finded, opposite;\n// //       finded = false;\n// //       while (!finded) {\n// //         if (count < datum.length) {\n// //           opposite = datum[count];\n// //           if (obj.target.id === opposite.source.id) {\n// //             finded = true;\n// //             last = opposite;\n// //             list.push(opposite.source);\n// //             datum.splice(count, 1);\n// //             recurse(last, datum);\n// //           }\n// //         } else {\n// //           finded = true;\n// //         }\n// //         ++count;\n// //       }\n// //     };\n// //     recurse(single, _data);\n// //     if (last != null) {\n// //       list.push(last.target);\n// //     } else {\n// //       list.push(single.target);\n// //     }\n// //     return list;\n// //   },\n\n// //   animate: function(){\n// //     setInterval(function(){\n// //         // config.rotation = config.rotation + 1;\n// //         console.log(config.innerRadius);\n// //         config.animation.innerRadius = config.animation.innerRadius + COS(config.iterate) * 50;\n// //         config.animation.outterRadius = config.animation.outterRadius - SIN(config.iterate - PI) * 80;\n// //           config.iterate += config.speed / 100;\n// //           dots.updateGradient();\n// //            dots.circularSVG();\n// //     }, 500);\n// //   },\n\n// //   updateGradient: function() {\n// //     var inner, outter;\n// //     let svg = dots.el.svg;\n// //     if (config.animated) {\n// //       inner = config.animation.innerRadius;\n// //       outter = config.animation.outterRadius;\n// //     } else {\n// //       inner = config.innerRadius;\n// //       outter = config.outterRadius;\n// //     }\n// //     if (inner < outter) {\n// //       svg.defs.select('#radial-gradient').attr(\"r\", \"\" + config.outterRadius + \"px\");\n// //       svg.defs.select('#radial-gradient').selectAll(\"stop\").each(function(d, i) {\n// //         var elem, percent;\n// //         elem = d3.select(this);\n// //         percent = 100;\n// //         if (i === 0) {\n// //           percent = (inner / outter) * 100;\n// //         }\n// //         return elem.attr(\"offset\", \"\" + percent + \"%\");\n// //       });\n// //     } else {\n// //       svg.defs.select('#radial-gradient').attr(\"r\", \"\" + inner + \"px\");\n// //       svg.defs.select('#radial-gradient').selectAll(\"stop\").each(function(d, i) {\n// //         var elem, percent;\n// //         elem = d3.select(this);\n// //         percent = 100;\n// //         if (i === 0) {\n// //           percent = (outter / inner) * 100;\n// //         }\n// //         return elem.attr(\"offset\", \"\" + percent + \"%\");\n// //       });\n// //     }\n// //   }\n// // };\n\n\n// // (function () {\n// //   var links, msToHour;\n\n// //   msToHour = function (ms) {\n// //     return Math.round(ms / 1000 / 60 / 60);\n// //   };\n\n// //   links = function (data, controls) {\n// //     var count,\n// //       currentTime,\n// //       delta,\n// //       exist,\n// //       hash,\n// //       index,\n// //       inverseHash,\n// //       key,\n// //       last,\n// //       lastObj,\n// //       lastTime,\n// //       link,\n// //       opposite,\n// //       oppositeHash,\n// //       oppositeInverseHash,\n// //       oppositeScope,\n// //       project,\n// //       scope,\n// //       task,\n// //       _i,\n// //       _j,\n// //       _k,\n// //       _l,\n// //       _len,\n// //       _len1,\n// //       _len2,\n// //       _len3,\n// //       _len4,\n// //       _links,\n// //       _m,\n// //       _ref,\n// //       _ref1;\n// //     links = [];\n// //     data.sort(function (a, b) {\n// //       return new Date(a.start) - new Date(b.start);\n// //     });\n// //     if (controls.overlapsTask) {\n// //       _ref = _.groupBy(data, \"project\");\n// //       for (key in _ref) {\n// //         project = _ref[key];\n// //         project.sort(function (a, b) {\n// //           return new Date(a.start) - new Date(b.start);\n// //         });\n// //         for (_i = 0, _len = project.length; _i < _len; _i++) {\n// //           task = project[_i];\n// //           scope = [new Date(task.start), new Date(task.end)];\n// //           for (_j = 0, _len1 = project.length; _j < _len1; _j++) {\n// //             opposite = project[_j];\n// //             if (task.id !== opposite.id) {\n// //               oppositeScope = [\n// //                 new Date(opposite.start),\n// //                 new Date(opposite.end),\n// //               ];\n// //               if (\n// //                 scope[0] <= oppositeScope[0] &&\n// //                 oppositeScope[0] <= scope[1]\n// //               ) {\n// //                 links.push({\n// //                   source: task.id,\n// //                   target: opposite.id,\n// //                   index: null,\n// //                 });\n// //               }\n// //             }\n// //           }\n// //         }\n// //       }\n// //     }\n// //     if (controls.followingTask) {\n// //       count = 0;\n// //       _ref1 = _.groupBy(data, \"project\");\n// //       for (key in _ref1) {\n// //         project = _ref1[key];\n// //         project.sort(function (a, b) {\n// //           return new Date(a.start) - new Date(b.start);\n// //         });\n// //         last = null;\n// //         lastObj = null;\n// //         for (_k = 0, _len2 = project.length; _k < _len2; _k++) {\n// //           task = project[_k];\n// //           if (last != null) {\n// //             lastTime = new Date(lastObj.start).getTime();\n// //             currentTime = new Date(task.start).getTime();\n// //             delta = currentTime - lastTime;\n// //             if (msToHour(delta) < controls.followingLimit) {\n// //               link = {\n// //                 source: last,\n// //                 target: task.id,\n// //                 index: count,\n// //               };\n// //               index = links.indexOf(link);\n// //               if (index < 0) {\n// //                 links.push(link);\n// //               }\n// //             } else {\n// //               count += 1;\n// //             }\n// //           }\n// //           last = task.id;\n// //           lastObj = task;\n// //         }\n// //         count += 1;\n// //       }\n// //     }\n// //     _links = [];\n// //     for (_l = 0, _len3 = links.length; _l < _len3; _l++) {\n// //       link = links[_l];\n// //       exist = false;\n// //       hash = link.source + \"-\" + link.target;\n// //       inverseHash = link.target + \"-\" + link.source;\n// //       for (_m = 0, _len4 = _links.length; _m < _len4; _m++) {\n// //         opposite = _links[_m];\n// //         oppositeHash = opposite.source + \"-\" + opposite.target;\n// //         oppositeInverseHash = opposite.target + \"-\" + opposite.source;\n// //         if (\n// //           hash === oppositeHash ||\n// //           hash === oppositeInverseHash ||\n// //           inverseHash === oppositeHash ||\n// //           inverseHash === oppositeInverseHash\n// //         ) {\n// //           exist = true;\n// //         }\n// //       }\n// //       if (!exist) {\n// //         _links.push(link);\n// //       }\n// //     }\n// //     return _links;\n// //   };\n\n// //   if (typeof window !== \"undefined\" && window !== null) {\n// //     window.linksTool = links;\n// //   } else {\n// //     module.exports = links;\n// //   }\n// // }.call(this));\n\n// // dots.init();\n"],"sourceRoot":""}